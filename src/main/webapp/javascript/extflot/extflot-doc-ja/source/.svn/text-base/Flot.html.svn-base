<html>
<head>
  <title>The source code</title>
    <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
    <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
</head>
<body  onload="prettyPrint();">
    <pre class="prettyprint lang-js">/* $Id:$
 * vim:sw=2:ts=8:sts=2:et:ft=javascript
 * Released under the MIT license and Ext Open Source License by NCS, December 2008-2009
 *
 * Project Home: http://code.google.com/p/extflot/
 * API Documentation: http://code.google.com/p/extflot/wiki/ApiDocumentation
 * Live Demo: http://extflot.googlecode.com/svn/trunk/index.html
 */

// dummy for no GetText
if (typeof _  != "function") {  _ = function(str) { return str; }; }

<div id="cls-Ext.ux.Flot"></div>/**
 * @class Ext.ux.Flot
 * @extends Ext.BoxComponent
 * <a href='http://code.google.com/p/extflot/'>http://code.google.com/p/extflot/</a>
 * <br>
 * flot は jQuery を用いたグラフ描画ライブラリです。
 *   <a href='http://code.google.com/p/flot/'>http://code.google.com/p/flot/</a>
 * <br>
 * Ext Flot は以下に依存しています。
<pre>
 Ext JS   2.2 and 2.2.1
 flot     0.5 (or latest revision of flot (r148 or later))
(Ext Flot 0.7a)
</pre>
 * <br>
 * flot 自体の API については <a href='http://flot.googlecode.com/svn/trunk/API.txt'>http://flot.googlecode.com/svn/trunk/API.txt</a>
 * を参照してください。
 *
 * @constructor
 * @param {Object} config 設定オブジェクト
 */
Ext.ux.Flot = Ext.extend(Ext.BoxComponent, {
  // protected version of Ext Flot
  version: "0.7a",

  <div id="cfg-Ext.ux.Flot-series"></div>/**
   * @cfg {Object} series 
   * flot series option
   */
  <div id="cfg-Ext.ux.Flot-baseSeries"></div>/**
   * @cfg {Object} baseSeries
   * 各系列に必ず付加されるオプション
   * Ext.apply されるので、この設定の記述がもっとも優先度が高いです
   */
  <div id="cfg-Ext.ux.Flot-type"></div>/**
   * @cfg {String} type 
   * データメンバの型
   * {@link Ext.data.Record.create} で使用されます
   * string int float boolean date
   */
  type: 'auto',
  <div id="cfg-Ext.ux.Flot-sortType"></div>/**
   * @cfg {Function} sortType 
   * {@link Ext.data.SortTypes} のいずれか
   * デフォルトは {@link Ext.data.SortTypes.asFloat} です
   * {@link Ext.data.Record.create} で使用されます
   */
  sortType: Ext.data.SortTypes.asFloat,

  <div id="cfg-Ext.ux.Flot-legend"></div>/**
   * @cfg {Object} legend
   * Flot legend options. It is passed to flot with not modified.
   */

  <div id="cfg-Ext.ux.Flot-xaxis"></div>/**
   * @cfg {Object} xaxis
   * flot xaxis
   */
  <div id="cfg-Ext.ux.Flot-yaxis"></div>/**
   * @cfg {Object} yaxis
   * flot yaxis
   */
  <div id="cfg-Ext.ux.Flot-x2axis"></div>/** 
   * @cfg {Object} x2axis
   * flot x2axis
   */
  <div id="cfg-Ext.ux.Flot-y2axis"></div>/**
   * @cfg {Object} y2axis
   * flot y2axis
   */
  <div id="cfg-Ext.ux.Flot-lines"></div>/**
   * @cfg {Object} lines
   * flot lines
   */
  <div id="cfg-Ext.ux.Flot-points"></div>/**
   * @cfg {Object} points
   * flot points
   */
  <div id="cfg-Ext.ux.Flot-bars"></div>/**
   * @cfg {Object} bars
   * flot bars
   */
  <div id="cfg-Ext.ux.Flot-pies"></div>/**
   * @cfg {Object} pies
   * Flot pies
   */
  <div id="cfg-Ext.ux.Flot-shadowSize"></div>/**
   * @cfg {Number} shadowSize
   * flot shadowSize
   */

  <div id="cfg-Ext.ux.Flot-grid"></div>/**
   * @cfg {Object} grid
   * flot grid options
   * 以下は独自拡張です
   * デフォルトで clicable と hoverable は on になります
   */
  <div id="cfg-Ext.ux.Flot-selection"></div>/**
   * @cfg {Object} selection
   * flot selection option
   * 以下は独自拡張です<br>
   *
<pre>
selection: {
  action:    'select' or 'zoom' or 'move' or null
  appendKey: 'shiftKey' or 'ctrlKey' or 'altKey'
  zoomDirection: 'tb' or 'bt' or 'lr' or 'rl'
  zoomWindow: 'ranges' or 'width' or 'height' or 'expand' or 'shrink'
  cursor: {
    select: 'default'
    zoom:   'crosshair'
    move:   'move'
  }
}
</pre>
   *
   * <li>action は選択時の挙動を指定します
   *   <ol>
   *   <li>select は選択した範囲内に点を選択します。
   *     shift キーを押しながら選択すると、追加されます。
   *     通常は、新規に選択しなおします。
   *     デフォルトの初期設定です。
   *   </li>
   *   <li>zoom は選択した範囲にズームインします。
   *     上方向 = zoom-in 下方向 = zoom-out
   *   </li>
   *   <li>move は選択範囲を移動します</li>
   *   </ol>
   * </li>
   * <li>appendKey は追加選択を行うキー設定です
   *   指定は DOM イベントのキーメンバ名で行います
   * </li>
   * <li>zoomDirection はズームイン・ズームアウトのマウス操作方向を設定します
   * <li>zoomWindow はズームイン・ズームアウト時の新しい表示範囲の決定法を設定します。
   *     デフォルトは 'expand' です。
   *   <ol>
   *   <li>ranges は選択範囲と同じにします。この場合、縦横比がズーム前とズーム後で変わります
   *   <li>width  は選択範囲の幅を基準にズームします
   *   <li>height は選択範囲の高さを基準にズームします
   *   <li>expand は選択範囲の幅高さのうちの長いほうの長さを基準にします
   *   <li>shrink は選択範囲の幅高さのうちの短いほうの長さを基準にします
   *   </ol>
   *
<pre>
    ズームイン    ズームアウト
tb: top (上へ)    bottom (下へ)
bt: bottom (下へ) top (上へ)
lr: left (左へ)   right (右へ)
rl: right (右へ)  left (左へ)
</pre>
   * </li>
   * <li>cursor は各モードのカーソル設定を指定します
   * 以下が指定可能なようです。
<pre>
crosshair, hand, move, text, wait, help, default, auto,
n-resize, s-resize, w-resize, e-resize, 
nw-resize, ne-resize, sw-resize, se-resize
</pre>
   * </li>
   *
   * TODO action ごとに選択領域の色を変えたい
   *   flot 0.5 では selection のオプションを動的に変える I/F がないため
   *   plot をしなおす必要がある
   */
  <div id="cfg-Ext.ux.Flot-crosshair"></div>/**
   * @cfg {Object} crosshair
   * flot crosshair option
   * This is not supported in flot 0.5
   */

  <div id="cfg-Ext.ux.Flot-width"></div>/**
   * @cfg {Integer/String} width
   * このコンポーネントの幅です。
   * 指定がない場合、親の幅と同じになります
   */
  <div id="cfg-Ext.ux.Flot-height"></div>/**
   * @cfg {Integer/String} height
   * このコンポーネントの高さです。
   * 指定がない場合、親の高さと同じになります
   */
  <div id="prop-Ext.ux.Flot-store"></div>/**
   * @property store
   * @type Ext.data.JsonStore
   * series のデータをミラーリングします
   */
  <div id="prop-Ext.ux.Flot-clickItem"></div>/**
   * @property clickItem
   * @type Object
   * 直近の plotclick の item です
   */
  <div id="prop-Ext.ux.Flot-hoverItem"></div>/**
   * @property hoverItem
   * @type Object 
   * 直近の plothover の item です
   */
  <div id="prop-Ext.ux.Flot-baseRanges"></div>/**
   * @property baseRanges
   * @type Object
   * 等倍(100%)表示の際の表示範囲です
   * plotselect の形式です
   */
  <div id="prop-Ext.ux.Flot-currentRanges"></div>/**
   * @property currentRanges
   * @type Object
   * 等倍(100%)表示でない場合の現在の表示範囲です
   * plotselect の形式です
   */

  <div id="prop-Ext.ux.Flot-contextMenu"></div>/**
   * @property contextMenu
   * @type Array
   * contextmenu イベントで表示するメニューです
   * これは <pre>new Ext.menu.Menu({ items: this.contextMenu })</pre> に引き渡されます
   * 追加する場合は、インスタンス生成後 (initComponent()) で、
   * push や concat をしてください。
   */
  contextMenu: [{
    name: 'select',
    text: _('Select'),
    iconCls: 'image_resize_actual',
    handler: function() { this.setSelectionAction('select'); }
  },{
    name: 'zoom',
    text: _('Zoom'),
    iconCls: 'magnifier_zoom',
    handler: function() { this.setSelectionAction('zoom'); }
  },{
    name: 'move',
    text: _('Move'),
    iconCls: 'magnifier__arrow',
    handler: function() { this.setSelectionAction('move'); }
  },'-',{
    name: 'actual',
    text: _('100%'),
    iconCls: 'magnifier_zoom_actual',
    handler: function() { 
      this.currentRanges = this.getRanges();
      this.zoomRatio(1.0); 
    }
  },'-',{
    name: 'selectall',
    text: _('Select All'),
    handler: function() { this.selectAll(); }
  },{
    name: 'unselectall',
    text: _('Unselect All'),
    handler: function() { this.unselectAll(); }
  },'-',{
    name: 'property',
    text: _('Property'),
    iconCls: 'puzzle',
    handler: function() { this.showProperty(); }
  }],

  <div id="prop-Ext.ux.Flot-datapointContextMenu"></div>/**
   * @property datapointContextMenu
   * @type Array 
   * データポイント上でクリックをした場合に表示されるメニューです
   * クリック位置が this.clickItem.page{X|Y} から 5 ピクセル以内の場合に
   * 表示されます
   */
  datapointContextMenu: [{
    name: 'selectalldatapoint',
    text: _('Select All Points'),
    iconCls: 'flag_plus',
    handler: function() { 
      var item = this.clickItem || this.hoverItem;
      if (item) { this.selectAll(item.series); }
    }
  },{
    name: 'unselectalldatapoint',
    text: _('Unselect All Points'),
    iconCls: 'flag_minus',
    handler: function() { 
      var item = this.clickItem || this.hoverItem;
      if (item) { this.unselectAll(item.series); }
    }
  },'-',{
    name: 'showseries',
    text: _('Show Series'),
    iconCls: 'database_plus',
    handler: function() { 
      var item = this.clickItem || this.hoverItem;
      if (item) { this.setHidden(item.series, false); }
    }
  },{
    name: 'hideseries',
    text: _('Hide Series'),
    iconCls: 'database_minus',
    handler: function() { 
      var item = this.clickItem || this.hoverItem;
      if (item) { this.setHidden(item.series, true); }
    }
  }],

  <div id="cfg-Ext.ux.Flot-basePropertyColumn"></div>/**
   * @cfg {Object} basePropertyColumn
   * PropertyGrid を生成する際の各カラムに適用される設定
   * {@link Ext.grid.ColumnModel} のオプション
   */
  <div id="prop-Ext.ux.Flot-propertyCmp"></div>/**
   * @property propertyCmp
   * @type Ext.Component
   * プロパティを表示するコンポーネントです。
   * 表示のタイミングは 'show' イベントを取ってください。
   */

  <div id="cfg-Ext.ux.Flot-tooltip"></div>/**
   * @cfg {Bool/String/Object} tooltip
   * string で与えた場合は、XTemplate によって整形されます。
   * 適用されれる XTemplate の引数は以下のオブジェクトです。
<pre>
{
   tipId:       event.target.id + '-tip',
   pageX:       pos.pageX,
   pageY:       pos.pageY,
   x:           pos.x,
   y:           pos.y,
   0:           item.datapoint[0],
   1:           item.datapoint[1],
   label:       item.series.label,
   color:       item.series.color,
   shadowSize:  item.series.shadowSize,
   dataIndex:   item.dataIndex,
   seriesIndex: item.seriesIndex
}
</pre>
   * <li>true の場合、
   * <pre><div id="{tipId}">{label} ({0}, {1})</div></pre>
   * になります。</li>
   * <li>Object で与えた場合、Ext.ToolTip のコンストラクタにそのまま
   * 引き渡されます</li>
   * TODO QuickTips には対応していません
   */
  tooltip: true,
  <div id="cfg-Ext.ux.Flot-tooltipEvent"></div>/**
   * @cfg {String} tooltipEvent
   * ツールチップを表示するイベントです
   * 以下の 3 種類の指定を受けつけます
   *  <li>plothover 
   *  <li>plotclick
   *  <li>all (plothover と plotclick)
   */
  tooltipEvent: 'plothover',
  <div id="prop-Ext.ux.Flot-disableTooltip"></div>/**
   * @property disableTooltip
   * @type Bool
   * ツールチップの有効・無効を設定します
   */

  <div id="prop-Ext.ux.Flot-flot"></div>/**
   * @property flot
   * @type Object
   * flot のグラフインスタンス
   * Read-only です。基本的にメソッドを介してアクセスしてください
   */

  // private
  initComponent: function() {
    // 設定の補完
    Ext.applyIf(this, {
      grid: {},
      xaxis: {},
      yaxis: {},
      selection: {},
      crosshair: {}
    });
    Ext.applyIf(this.grid, {
      clickable: true,
      hoverable: true
    });
    Ext.applyIf(this.selection, {
      mode:          "xy", 
      action:        'select',
      appendKey:     'shiftKey',
      zoomDirection: 'tb',
      zoomWindow:    'expand',
      cursor: {}
    });
    Ext.applyIf(this.selection.cursor, {
      select: 'default',
      zoom:   'crosshair',
      move:   'move'
    });

    // data のミラーリング
    this.store = this.store || new Ext.data.JsonStore({});

    // 選択された点群
    this.selected = [];

    // コンテキストメニューを Ext.Action 化する
    this.actions = {};
    var keys = ['contextMenu', 'datapointContextMenu'];
    for (var k = 0; k < keys.length; k++) {
      var key = keys[k];
      if (this[key]) {
        var menu = [];
        var contextMenu = this[key];
        for (var i = 0, len = contextMenu.length; i < len; i++) {
          if (typeof contextMenu[i] == 'object') {
            var action = new Ext.Action(Ext.apply({scope: this}, contextMenu[i]));
            this.actions[contextMenu[i].name] = action;
            menu.push(action);
          } else {
            menu.push(contextMenu[i]);
          }
        }
        this[key] = menu;
      }
    }

    Ext.ux.Flot.superclass.initComponent.call(this);
    this.addEvents(
      <div id="event-Ext.ux.Flot-click"></div>/**
       * @event click
       * @param {OBject} event
       * Flot コンポーネントのどこかがクリックした場合に発行されます
       * false を返すと、Flot に設定されている動作をしません。
       */
      "click",
      <div id="event-Ext.ux.Flot-dblclick"></div>/**
       * @event dblclick
       * @param {OBject} event
       * false を返すと、Flot に設定されている動作をしません。
       */
      "dblclick",
      <div id="event-Ext.ux.Flot-contextmenu"></div>/**
       * @event contextmenu
       * @param {OBject} event
       * false を返すと、標準の contextmenu (this.contextMenu) を表示しません
       */
      "contextmenu",
      <div id="event-Ext.ux.Flot-beforedraw"></div>/**
       * @event beforedraw
       * flot の(再)描画実行前に発行されます
       * false を返すと、Flot に設定されている動作をしません。
       * @param {Ext.ux.Flot} this
       * @param {Object} series
       */
      "beforedraw",
      <div id="event-Ext.ux.Flot-draw"></div>/**
       * @event draw
       * flot の(再)描画実行後に発行されます
       * @param {Ext.ux.Flot} this
       * @param {Object} series
       */
      "draw",
      <div id="event-Ext.ux.Flot-plotselected"></div>/**
       * @event plotselected
       * 矩形領域の選択
       * series.selectable が true である場合のみ有効です
       * false を返すと、Flot に設定されている動作をしません。
       * それ以外の場合は、selection.action に設定されている動きをします
       * @param {Ext.ux.Flot} this
       * @param {Object} event イベントオブジェクト
       * @param {Object} range 選択範囲矩形
       * {x: xpos, y: ypos, x2: xpos2, y2: ypos2}
       * @param {Object} item 選択されたアイテム
       * null でない場合は選択されたデータ点等が入っています
       * <li>datapoint [0, 2] のような、選択された系列のデータ点
       * <li>dataIndex 選択されたデータ点の data 内のインデックス
       * <li>series    選択された系列
       * <li>seriesIndex 選択された系列の data 内のインデックス
       * <li>pageX     選択された点のグローバルスクリーン内の座標
       * <li>pageY
       */
      "plotselected",
      <div id="event-Ext.ux.Flot-plotselecting"></div>/**
       * @event plotselecting
       * 矩形領域の選択中
       * 領域選択のドラッグ中に呼び出されます。
       * 引数は plotselected と同様です
       * flot 0.5 では未対応です
       * @param {Ext.ux.Flot} this
       * @param {Object} event イベントオブジェクト
       * @param {Object} range 選択範囲矩形
       * @param {Object} item 選択されたアイテム
       */
      "plotselecting",
      <div id="event-Ext.ux.Flot-plothover"></div>/**
       * @event plothover
       * grid.hoverable が true である場合のみ有効です
       * false を返すと、Flot に設定されている動作をしません。
       * キャンバス上をマウスが通過している際に発行されます
       * item がある場合は、その点の上を通過しています
       * @param {Ext.ux.Flot} this
       * @param {Object} event イベントオブジェクト
       * @param {Object} pos
       * クリックされた位置
       * {x: xpos, y: ypos, x2: xpos2, y2: ypos2}
       * @param {Object} item クリックされたアイテム
       * "plotselected" イベントの item と同じです
       */
      "plothover",
      <div id="event-Ext.ux.Flot-plotclick"></div>/**
       * @event plotclick
       * clickable が true である場合のみ有効です
       * キャンバス上でマウスクリックが行われた場合に発行されます
       * item がある場合は、その点をクリックしています
       * @param {Ext.ux.Flot} this
       * @param {Object} event イベントオブジェクト
       * @param {Object} pos
       * クリックされた位置
       * {x: xpos, y: ypos, x2: xpos2, y2: ypos2}
       * @param {Object} item クリックされたアイテム
       * "plotselected" イベントの item と同じです
       */
      "plotclick",
      <div id="event-Ext.ux.Flot-plotshow"></div>/**
       * @event plotshow
       * 系列が表示された
       * @param {Ext.ux.Flot} this
       * @param {Object} series 表示された系列
       */
      "plotshow",
      <div id="event-Ext.ux.Flot-plothide"></div>/**
       * @event plothide
       * 系列が隠された
       * @param {Ext.ux.Flot} this
       * @param {Object} series 隠された系列
       */
      "plothide",
      <div id="event-Ext.ux.Flot-selectionactionchange"></div>/**
       * @event selectionactionchange
       * @param {Ext.ux.Flot} this
       * @param {String} action 選択された点群
       */
      "selectionactionchange",
      <div id="event-Ext.ux.Flot-selectionchange"></div>/**
       * @event selectionchange
       * 選択点群が変更された
       * @param {Ext.ux.Flot} this
       * @param {Array} selected 選択された点群
       * getSelected() と同じ形式です
       */
      "selectionchange",
      <div id="event-Ext.ux.Flot-legendclick"></div>/**
       * @event legendclick
       * 凡例がクリックされた
       * @param {Ext.ux.Flot} this
       * @param {Ext.Element} legend (legendColorBox ro legendLabel)
       * @param {Object} series 対応する系列
       * false を返すと、Flot に設定されている動作をしません。
       */
      "legendclick");
  },

  <div id="method-Ext.ux.Flot-createStoreData"></div>/**
   * flot 系列データ (series) から Ext.data.JsonStore 用の Object を生成します。
   * これは Ext.data.JsonStore.loadData() に読み込ませることができます。
   * metaData を含む、HttpResponse 用と同じ形式を返します。
   * 実データのルートは 'data' です。
   * @param {Object} series ストアデータ化する系列です。
   * 指定なしの場合は、インスタンスが保持している系列 getData() から生成します。
   * @return {Object} Ext.data.JsonStore loadData() 用のオブジェクト
   */
  createStoreData: function(series) {
    series = series || this.getData();
    var axes = this.getAxes();
    var fields = [];
    var keys = ['xaxis', 'x2axis'];
    for (var k = 0; k < keys.length; k++) {
      fields.push({
        name: keys[k],
        xColumn: true,
        type: this.type,
        sortType: this.sortType
      });
    }
    var hash = {};
    for (var i = 0, len = series.length; i < len; i++) {
      var s = series[i];
      var name = s.label || i;
      var xaxis = (s.xaxis == axes.x2axis) ? 'x2axis' : 'xaxis';
      fields.push({ 
        name: name,
        type: this.type,
        sortType: this.sortType
      });

      for (var j = 0, dlen = s.data.length; j < dlen; j++) {
        var src  = s.data[j];
        if (src) {
          var dest = hash[src[0]] = hash[src[0]] || {};
          dest[xaxis]   = src[0];
          dest[name] = src[1];
        }
      }
    }
    var data = [];
    for (var key in hash) { data.push(hash[key]); }

    return {
      metaData: {
        root: 'data',
        totalProperty: 'total',
        successProperty: 'success',
        sortInfo: { field: 'xaxis', direction: 'ASC' },
        fields: fields
      },
      data:  data,
      total: data.length,
      success: true
    };
  },

  <div id="method-Ext.ux.Flot-createSeries"></div>/**
   * store のデータを基に系列を生成します
   * 生成される各系列は {@link Ext.data.Store} 用の以下の拡張を含んでいます
   *  <li>dataIndex
   *  <li>type
   *  <li>sortType
   * @param {Ext.data.Store} store 使用するデータストア
   * 指定がなかった場合は this.store が使用されます
   * @param {String} field X 軸に設定するフィールド
   * dataIndex, name の順でマッチングされます
   * @return {Array} flot が利用可能な系列の配列
   */
  createSeries: function(store, xColumn) {
    store = store || this.store;
    if (typeof xColumn == 'undefined') { xColumn = store.xColumn; }
    var i, len;
    var series = [];
    for (i = 0, len = store.fields.keys.length; i < len; i++) {
      var finfo = store.fields.items[i];
      var idx   = finfo.dataIndex || finfo.name;
      if (xColumn == idx) { continue; }
      series.push({
        label:     finfo.name, 
        dataIndex: idx, 
        type:      this.type,
        sortType:  this.sortType,
        data: []
      });
    }
    store.each(function(rec) {
      var series = this.series;
      var store  = this.store;
      var x = rec.get(this.xColumn);
      for (var i = 0, len = series.length; i < len; i++) {
        var val = rec.get(series[i].dataIndex);
        series[i].data.push([x, val]);
      }
    }, { series: series, store: store, xColumn: xColumn });
    return series;
  },

  <div id="method-Ext.ux.Flot-getStore"></div>/**
   * このインスタンスが保持している Store を得ます
   * @return {Ext.data.JsonStore} 保持している JsonStore
   */
  getStore: function() {
    return this.store;
  },

  <div id="method-Ext.ux.Flot-clipData"></div>/**
   * range で与えた領域に存在している datapoints を集めてきます
   * @param {Object} ranges
   * ranges は以下の各メンバの中に from to を持っています。
   * from と to の単位は、それぞれの系列の値の単位であることに注意してください。
   *  * xaxis yaxis x2axis y2axis
   *    * from to
   * @return {Array} 各系列の range 内の点群
   */
  clipData: function(ranges) {
    var series = this.getData();
    var axes = this.getAxes();
    var clipped = [];
    for (var i = 0, len = series.length; i < len; i++) {
      var s = series[i];
      clipped[i] = {};
      clipped[i].series = s;
      clipped[i].datapoints = [];
      var xaxis = s.xaxis == axes.x2axis ? 'x2axis' : 'xaxis';
      var yaxis = s.yaxis == axes.y2axis ? 'y2axis' : 'yaxis';
      for (var j = 0, n = s.data.length; j < n; j++) {
        var d = s.data[j];
        if (d &&
            ranges[xaxis].from <= d[0] &&
            ranges[xaxis].to   >= d[0] &&
            ranges[yaxis].from <= d[1] &&
            ranges[yaxis].to   >= d[1]) {
          clipped[i].datapoints.push([d[0], d[1]]);
        }
      }
    }
    return clipped;
  },

  // private
  onRender: function(ct, position) {
    if (!this.template) {
      if (!Ext.ux.Flot.flotTemplate) {
        // 0: DOM ID for container
        Ext.ux.Flot.flotTemplate = new Ext.Template('<div id="{0}"></div>');
      }
      this.template = Ext.ux.Flot.flotTemplate;
    }
    var id = this.id || Ext.id(null, 'flot-container');
    var el, targs = [id];

    if (position) {
      el = this.template.insertBefore(position, targs, true);
      //ct = position;
    }else{
      el = this.template.append(ct, targs, true);
    }
    this.el = el;
    if (this.id) { this.el.dom.id = this.el.id = this.id; }
    this.el.setWidth( this.width  || ct.getWidth());
    this.el.setHeight(this.height || ct.getHeight());
    this.el.setStyle('cursor', this.selection.cursor[this.selection.action]);

    // draw el
    var series = this.series;
    if (this.data) { series = this.setupData(this.data, series); }
    if (series) {
      // 系列をセットアップして描画
      series = this.setupSeries(series);
      this.plot(series);

      // hidden の初期設定を行う
      series = this.getData();
      for (var i = 0, len = series.length; i < len; i++) {
        var s = series[i];
        if (s.hidden) {
          s.hidden = !s.hidden;
          this.setHidden(s, !s.hidden);
        }
      }
      this.baseRanges = this.getRanges();
    }
  },

  // private
  afterRender: function() {
    Ext.ux.Flot.superclass.afterRender.call(this);
    this.el.on({
      "mousedown":   this.onMouseDown,
      "mouseup":     this.onMouseUp,
      "mouseout":    this.onMouseOut,
      "click":       this.onClick,
      "dblclick":    this.onDblClick,
      "contextmenu": this.onContextMenu,
      scope: this
    });

    $('#' + this.id).bind('plotselected', function(event, range) {
      flot = Ext.getCmp(event.target.id);
      flot.onPlotSelected(event, range);
    });
    $('#' + this.id).bind('plotselecting', function(event, range) {
      flot = Ext.getCmp(event.target.id);
      flot.onPlotSelecting(event, range);
    });
    $('#' + this.id).bind('plothover', function(event, pos, item) {
      flot = Ext.getCmp(event.target.id);
      flot.onPlotHover(event, pos, item);
    });
    $('#' + this.id).bind('plotclick', function(event, pos, item) {
      flot = Ext.getCmp(event.target.id);
      flot.onPlotClick(event, pos, item);
    });

    this.updateAction();

    if (this.tooltip) {
      this.on(this.tooltipEvent, function(flot, event, pos, item) {
        if (item) {
          if (!this.prevTooltipItem || 
              this.prevTooltipItem.datapoint[0] != item.datapoint[0] ||
              this.prevTooltipItem.datapoint[1] != item.datapoint[1] ||
              this.prevTooltipItem.series       != item.series) {
            this.showTooltip(event, pos, item); 
            this.prevTooltipItem = item;
          }
        }
      }, this);
    }
  },

  // private
  onResize: function(adjWidth, adjHeight, rawWidth, rawHeight) {
    //Ext.ux.Flot.superclass.onResize.call(this, adjWidth, adjHeight, rawWidth, rawHeight);
    this.el.setWidth(adjWidth);
    this.el.setHeight(adjHeight);
    try {
      this.plot(this.getData());
    } catch (e) {
      if (typeof e == 'string') {
        this.onResize.defer(200, this, [adjWidth, adjHeight, rawWidth, rawHeight]);
      }
    }
    this.syncSelected();
  },

  // private
  setupLegend: function() {
    // handle click of legend
    var legend_tbody = this.el.query("div.legend > table > tbody")[0];
    if (legend_tbody) {
      var series = this.getData();
      this.legendCmp = new Ext.Element(legend_tbody);
      this.legendEls = {};
      var color_boxes = this.legendCmp.query("tr > td.legendColorBox");
      var labels      = this.legendCmp.query("tr > td.legendLabel");
      for (var i = 0, len = series.length; i < len; i++) {
        var s = series[i];
        var idx = -1;
        for (var j = 0; j < labels.length; j++) {
          var text = labels[j].textContent || labels[j].innerHtml;
          if (text == s.label) { 
            idx = j; 
            break; 
          }
        }
        if (idx >= 0) {
          var cb = new Ext.Element(color_boxes[idx]);
          var lb = new Ext.Element(labels[idx]);
          cb.on('click', this.onLegendClick, this, {series: s});
          lb.on('click', this.onLegendClick, this, {series: s});
          var c = this.legendEls[s.label] || {};
          if (c.hidden != s.hidden) { (s.hidden) ? cb.fadeOut() : cb.fadeIn(); }
          if (s.hidden) { cb.hide(); }
          this.legendEls[s.label] = Ext.apply(c, {
            legendColorBox: cb, 
            legendLabel: lb, 
            series: s,
            hidden: s.hidden
          });
        }
      }
    }
  },

  // private
  onDraw: function() {
    this.setupLegend();
    this.store.loadData(this.createStoreData());
    this.fireEvent('draw', this);
  },

  // private
  onSelectionChange: function() {
    this.updateAction();
    this.fireEvent('selectionchange', this, this.selected);
  },

  // private
  onLegendClick: function(e, legendDom, args) {
    var s = args.series;
    if (this.fireEvent('legendclick', this, Ext.get(legendDom), s) !== false) {
      this.setHidden(s, !s.hidden);
    }
  },

  // private
  onMouseDown: function(e) {
    this.lastEvent = this.mouseDownEvent = Ext.apply({}, e);
  },

  // private
  onMouseUp: function(e) {
    this.lastEvent = this.mouseUpEvent = Ext.apply({}, e);
  },

  // private
  onMouseOut: function(e) {
    this.lastEvent = this.mouseUpEvent = Ext.apply({}, e);
  },

  // private
  onClick: function(e) {
    this.fireEvent("click", this, e);
  },

  // private
  onDblClick: function(e) {
    if (this.fireEvent("dblclick", this, e) !== false) {
      if (this.selection.action == 'select') {
        this;   // nothing to do
      } else {  // zoom, move
        if (this.applyRanges == 'baseRanges') {
          this.applyRanges = 'currentRanges';
        } else {
          this.currentRanges = this.getRanges();
          this.applyRanges = 'baseRanges';
        }
        this.zoom(this[this.applyRanges]);
      }
    }
  },

  // private
  onContextMenu: function(e) {
    if (this.fireEvent("contextmenu", this, e) !== false) {
      var contextMenu = this.contextMenu;
      if (this.clickItem) {
        if (Math.abs(e.xy[0] - this.clickItem.pageX) <= 5 &&
            Math.abs(e.xy[1] - this.clickItem.pageY) <= 5) {
          contextMenu = this.datapointContextMenu || contextMenu;
        }
      }
      if (contextMenu) {
        var menu = new Ext.menu.Menu({ items: contextMenu });
        e.stopEvent();
        menu.showAt(e.getXY());
      }
    }
  },

  // private
  onPlotSelecting: function(event, ranges) {
    this.fireEvent('plotselecting', this, event, ranges);
  },

  // private
  onPlotSelected: function(event, ranges) {
    if (this.fireEvent('plotselected', this, event, ranges) !== false) {
      if (!this.mouseDownEvent || !this.mouseUpEvent) { return; }
      var diff_px = [ 
        this.mouseDownEvent.xy[0] - this.mouseUpEvent.xy[0],
        this.mouseDownEvent.xy[1] - this.mouseUpEvent.xy[1]
      ];
      var axes = this.getAxes();
      var r = {};
      var keys = ['xaxis', 'yaxis', 'x2axis', 'y2axis'], k, axis;

      switch (this.selection.action) {
        case 'select':
          if (!this.lastEvent[this.selection.appendKey]) {this.unselectAll();}
          var d = this.clipData(ranges);
          var changed = false;
          for (var i = 0, len = d.length; i < len; i++) {
            for (var j = 0, dlen = d[i].datapoints.length; j < dlen; j++) {
              if (this.addSelected(d[i].series, d[i].datapoints[j])) { changed = true; }
            }
          }
          if (changed) {this.onSelectionChange();}
          break;
        case 'zoom':
          var xmin, xmax, ymin, ymax;
          var x2min, x2max, y2min, y2max;
          var zoom = {}, zoomin, z;
          var w  = this.el.getWidth();
          var h  = this.el.getHeight();
          var rw = Math.abs(diff_px[0]);
          var rh = Math.abs(diff_px[1]);
          var fix_x = false, fix_y = false;
          switch (this.selection.zoomWindow) {
            case 'ranges': break;
            case 'expand': fix_x = (rw < rh); fix_y = (rw > rh); break;
            case 'shrink': fix_x = (rw > rh); fix_y = (rw < rh); break;
            case 'width':  fix_y = true; break;
            case 'height': fix_x = true; break;
            default: break; // ranges
          }
          for (k = 0; k < keys.length; k++) {
            axis = keys[k];
            if (!axes[axis].used) { 
              zoom[axis] = null;
              continue;
            } 
            zoom[axis] = z = {
              from:        ranges[axis].from,
              to:          ranges[axis].to,
              center:      (ranges[axis].from + ranges[axis].to) / 2,
              min:         axes[axis].min,
              max:         axes[axis].max,
              axisLength:  axes[axis].max - axes[axis].min,
              rangeLength: ranges[axis].to - ranges[axis].from
            };

            var scale = null;
            if        (axis[0] == 'x' && fix_x) {
              scale = rh / rw * w / h;
            } else if (axis[0] == 'y' && fix_y) {
              scale = rw / rh * h / w;
            }
            if (scale !== null) {
              z.fromOrg = z.from;
              z.toOrg   = z.to;
              z.from = z.center + (z.from - z.center) * scale;
              z.to   = z.center + (z.to   - z.center) * scale;
              z.rangeLength = z.to - z.from;
            } 
          }
          switch (this.selection.zoomDirection) {
            case 'tb': zoomin = diff_px[1] >= 0; break;
            case 'bt': zoomin = diff_px[1] <= 0; break;
            case 'lr': zoomin = diff_px[0] >= 0; break;
            case 'rl': zoomin = diff_px[0] <= 0; break;
            default:   zoomin = diff_px[1] >= 0; break; // tb
          }
          for (k = 0; k < keys.length; k++) {
            axis = keys[k];
            z = zoom[axis];
            if (!z) { continue; }
            if (zoomin) {
              r[axis] = { min: z.from, max: z.to };
            } else {
              r[axis] = {
                min: z.min + (z.min - z.from) * z.axisLength / z.rangeLength,
                max: z.max + (z.max - z.to)   * z.axisLength / z.rangeLength
              };
            }
          }
          this.zoom(r);
          break;
        case 'move':
          var to_left   = (diff_px[0] <= 0) ? true : false;
          var to_bottom = (diff_px[1] >= 0) ? true : false;
          for (k = 0; k < keys.length; k++) {
            axis = keys[k];
            if (!axes[axis].used) { continue; }
            var diff = ranges[axis].to  - ranges[axis].from;
            diff = ((axis[0] == 'x') ? to_left : to_bottom) ? -diff: diff;
            r[axis] = {
              min: axes[axis].min + diff, 
              max: axes[axis].max + diff
            };
          }
          this.zoom(r);
          break;
        default:
          break;
      }
    }
  },

  // private
  onPlotHover: function(event, pos, item)  {
    this.hoverItem = item;
    this.fireEvent('plothover', this, event, pos, item);
  },

  // private
  onPlotClick: function(event, pos, item)  {
    this.clickItem = item;
    if (this.fireEvent('plotclick', this, event, pos, item) !== false) {
      if (item) {
        if (item.series.selectable) {
          if (!this.lastEvent[this.selection.appendKey]) {this.unselectAll();}
          if (!this.addSelected(item.series, item.datapoint)) {
            this.removeSelected(item.series, item.datapoint);
          }
          this.onSelectionChange();
        }
      } else {
        if (!this.lastEvent[this.selection.appendKey]) { this.unselectAll(); }
      }
    }
  },

  <div id="method-Ext.ux.Flot-setSelectionAction"></div>/**
   * 範囲選択時の動作を設定します
   * @param {String} action 'select' or 'move' or 'zoom'
   */
  setSelectionAction: function(action) {
    this.selection.action = action;
    this.el.setStyle('cursor', this.selection.cursor[this.selection.action]);
    this.updateAction();
    this.fireEvent('selectionactionchange', this, action);
  },

  <div id="method-Ext.ux.Flot-getSelectionAction"></div>/**
   * カレントの範囲選択時の動作設定を取得します
   * @return {String} select zoom move のいずれか
   */
  getSelectionAction: function() {
    return this.selection.action;
  },

  <div id="method-Ext.ux.Flot-getRanges"></div>/**
   * カレントの表示範囲を取得します
   * @return 表示範囲情報
   */
  getRanges: function() {
    var series = this.getData();
    var axes   = this.getAxes();
    var r = {};
    if (axes.xaxis)  { r.xaxis  = {min: axes.xaxis.min,  max: axes.xaxis.max};}
    if (axes.yaxis)  { r.yaxis  = {min: axes.yaxis.min,  max: axes.yaxis.max};}
    if (axes.x2axis) { r.x2axis = {min: axes.x2axis.min, max: axes.x2axis.max};}
    if (axes.y2axis) { r.y2axis = {min: axes.y2axis.min, max: axes.y2axis.max};}
    return r;
  },

  <div id="method-Ext.ux.Flot-zoom"></div>/**
   * 表示領域をズームします。
   * ズームインするかズームアウトするかは、現在の領域と与えた領域との関係によります
   * @param {Object} range ズームする範囲
   */
  zoom: function(ranges) {
    var keys = ['xaxis', 'yaxis', 'x2axis', 'y2axis'];
    for (var k = 0; k < keys.length; k++) {
      // from to -> min max
      var key = keys[k];
      var r = ranges[key];
      if (r) {
        if (typeof r.min == 'undefined') r.min = r.from;
        if (typeof r.max == 'undefined') r.max = r.to;
        Ext.apply(this[key], r);
      }
    }
    this.plot(this.getData());
  },

  <div id="method-Ext.ux.Flot-zoomRatio"></div>/**
   * カレントの表示領域に対する比率でズームします。
   * @param {Number} ratio 1.0 が 100% です
   */
  zoomRatio: function(ratio) {
    var b = this.baseRanges;
    var r = {};
    if (b.xaxis)  { r.xaxis  = {min: b.xaxis.min  * ratio, max: b.xaxis.max  * ratio}; }
    if (b.yaxis)  { r.yaxis  = {min: b.yaxis.min  * ratio, max: b.yaxis.max  * ratio}; }
    if (b.x2axis) { r.x2axis = {min: b.x2axis.min * ratio, max: b.x2axis.max * ratio}; }
    if (b.y2axis) { r.y2axis = {min: b.y2axis.min * ratio, max: b.y2axis.max * ratio}; }
    this.zoom(r);
  },

  // private
  syncSelected: function() {
    for (var i = 0; i < this.selected.length; i++) {
      var selected = this.selected[i];
      selected.series = this.findSeries(selected.series.id);
      for (var j = 0; j < selected.datapoints.length; j++) {
        this.highlight(selected.series, selected.datapoints[j]);
      }
    }
  },

  // private
  addSelectedPoint: function(selected, datapoint) {
    i = selected.datapoints.indexOf(datapoint);
    if (i < 0) {
      selected.datapoints.push(datapoint);
      this.highlight(selected.series, datapoint);
      return true;
    }
    return false;
  },

  <div id="method-Ext.ux.Flot-addSelected"></div>/**
   * 系列のデータ点を選択状態に追加します
   * @param {Object} seris 追加する点を保持する系列
   * @param {Object} datapoint 追加する点
   * @return {Boolean} 実際に datapoint が追加されたか
   */
  addSelected: function(series, datapoint) {
    if (!this.selection || !series.selectable) {return false;}
    var selected = null, i, len;
    for (i = 0, len = this.selected.length; i < len; i++) {
      if (this.selected[i].series == series) { 
        selected = this.selected[i];
        break; 
      }
    }
    if (!selected) { 
      selected = {series: series, datapoints: []};
      this.selected.push(selected); 
    }

    return this.addSelectedPoint(selected, datapoint);
  },

  <div id="method-Ext.ux.Flot-selectAll"></div>/**
   * すべての点を選択します
   * @param {String/Object} _series すべての点を選択する系列
   * 指定なしの場合は、すべての系列を選択します
   */
  selectAll: function(_series) {
    if (!this.selection) { return; }
    if (typeof _series == 'string') { _series = this.findSeries(_series); }
    var changed = false;
    var series = this.getData();
    this.selected = [];
    for (var i = 0, len = series.length; i < len; i++) {
      if (typeof _series != 'undefined' && _series != series[i]) { continue; }
      if (!series[i].selectable) { continue; }
      var selected = {series: series[i], datapoints: []};
      this.selected.push(selected);
      for (var j = 0, dlen = series[i].data.length; j < dlen; j++) {
        if (this.addSelectedPoint(selected, series[i].data[j])) {
          changed = true;
        }
      }
    }
    if (changed) { this.onSelectionChange(); }
  },

  <div id="method-Ext.ux.Flot-removeSelected"></div>/**
   * 系列のデータ点を選択状態からさ駆除します
   * @param {Object} seris 削除する点を保持する系列
   * @param {Object} datapoint 削除する点
   */
  removeSelected: function(series, datapoint) {
    for (var i = 0, len = this.selected.length; i < len; i++) {
      var s = this.selected[i];
      if (s.series == series) { 
        this.unhighlight(series, datapoint);
        s.datapoints.remove(datapoint);
        break; 
      }
    }
  },

  <div id="method-Ext.ux.Flot-unselectAll"></div>/**
   * 現在の選択を解除します
   * @param {String/Object} _series
   */
  unselectAll: function(_series) {
    var changed = false;
    if (typeof _series == 'string') { _series = this.findSeries(_series); }
    for (var i = 0, len = this.selected.length; i < len; i++) {
      var s = this.selected[i];
      if (typeof _series != 'undefined' && _series != s.series) { continue; }
      for (var j = 0, dlen = s.datapoints.length; j < dlen; j++) {
        this.unhighlight(s.series, s.datapoints[j]);
      }
      changed = true;
      s.datapoints = [];
    }
    if (changed) { this.onSelectionChange(); }
  },

  <div id="method-Ext.ux.Flot-getSelected"></div>/**
   * 選択されている点群を array で返します
   * この点群は series と datapoints を持つ配列です
<pre>
[{
  series: <series>
  datapoints: [[<x>, <y>], ...]
}, ...]
</pre>
   * @return {Array} 選択されている点群
   */
  getSelected: function() {
    return this.selected;
  },

  <div id="method-Ext.ux.Flot-getSelectedRecords"></div>/**
   * @param {Object} selected getSelected() で取得できる選択された点
   * @return {Array} {@link Ext.data.Record} 化されたデータ点群
   */
  getSelectedRecords: function(selected) {
    var records = [];
    selected = selected || this.getSelected();
    for (var i = 0, len = selected.length; i < len; i++) {
      for (var j = 0, dlen = selected[i].datapoints.length; j < dlen; j++) {
        var dp = selected[i].datapoints[j];
        var xkey = selected[i].series.x2axis ? 'x2axis': 'xaxis';
        var idx = this.store.find(xkey, dp[0]);
        records.push(this.store.getAt(idx));
      }
    }
    return records;
  },

  // private
  setActionDisabled: function(key, disabled) {
    if (this.actions[key]) { this.actions[key].setDisabled(disabled); }
  },

  // private
  updateAction: function() {
    this.setActionDisabled('zoom',   this.selection.action === 'zoom');
    this.setActionDisabled('select', this.selection.action === 'select');
    this.setActionDisabled('move',   this.selection.action === 'move');
    var n_selected = 0, i, len;
    for (i = 0, len = this.selected.length; i < len; i++) {
      n_selected += this.selected[i].datapoints.length;
    }
    this.setActionDisabled('unselectall', this.selected.length === 0 || n_selected === 0);
    this.setActionDisabled('property',   !this.hasProperty());
    var item = this.clickItem || this.hoverItem;
    if (item) {
      n_selected = 0;
      for (i = 0, len = this.selected.length; i < len; i++) {
        if (this.selected[i].series == item.series) {
          n_selected = this.selected[i].datapoints.length;
          break;
        }
      }
      this.setActionDisabled('selectalldatapoint',   !item.series);
      this.setActionDisabled('unselectalldatapoint', !item.series || n_selected === 0);
      this.setActionDisabled('showseries',           !item.series.hidden);
      this.setActionDisabled('hideseries',           item.series.hidden);
    }
  },

  // private
  hasProperty: function() {
    return true;
  },

  // private
  showProperty: function() {
    if (!this.propertyCmp) {
      // ウィンドウを生成
      this.propertyCmp = new Ext.Window({
        closeAction: 'hide',
        layout: 'fit',
        width: 400,
        height: 300,
        items: [{
          xtype: 'flotpropertygrid',
          flot: this,
          layout: 'fit'
        }]
      });
      // バインディング
      var grid = this.propertyCmp.findByType('flotpropertygrid')[0];
      this.bindGrid(grid);
    }
    this.propertyCmp.show();
  },

  <div id="method-Ext.ux.Flot-bindGrid"></div>/**
   * Ext.ux.Flot と Ext.grid.GridPanel を相互に関連づけます
   * @param {Ext.grid.GridPanel} grid 関連づけるグリッド
   */
  bindGrid: function(grid) {
    this.on('selectionchange', function(flot, selected) {
      var records = flot.getSelectedRecords(selected);
      var cm = this.getColumnModel();
      var sm = this.getSelectionModel();
      for (var i = 0, len = records.length; i < len; i++) {
        var rec = records[i];
        var x = this.store.indexOf(rec);
        for (var key in rec.data) {
          if (typeof rec.data.key != "undefined") {
            var y = cm.findColumnIndex(key);
            sm.select(x, y);
          }
        }
      }
    }, grid);
    grid.getSelectionModel().on('selectionchange', function(sm) {
    }, this);
  },

  // private
  showTooltip: function(event, pos, item) {
    if (!this.tooltip || this.disableTooltip) { return; }
    var c = {
      renderTo: Ext.getBody(),
      //targetXY: [item.pageX, item.pageY]
      targetXY: [pos.pageX, pos.pageY]
    };
    var tooltip = this.tooltip;
    if (typeof tooltip == 'boolean') { 
      tooltip = '<div id="{tipId}">{label} ({0}, {1})</div>'; 
    }
    if (typeof tooltip == 'string') { 
      if (!this.tipTemplate) {
        this.tipTemplate = new Ext.XTemplate(tooltip);
      }
      c.html = this.tipTemplate.apply({
        tipId:       event.target.id + '-tip',
        pageX:       pos.pageX,
        pageY:       pos.pageY,
        x:           pos.x,
        y:           pos.y,
        0:           item.datapoint[0],
        1:           item.datapoint[1],
        label:       item.series.label,
        color:       item.series.color,
        shadowSize:  item.series.shadowSize,
        dataIndex:   item.dataIndex,
        seriesIndex: item.seriesIndex
      });
    } else if (typeof tooltip == 'object') { 
      Ext.apply(c, this.tooltip); 
    }
    var tt = new Ext.ToolTip(c);
    tt.show();
  },

  <div id="method-Ext.ux.Flot-setTooltipDisable"></div>/**
   * ツールチップを有効・無効にします
   * @param {Bool} disable false で有効 true で無効
   */
  setTooltipDisable: function(disable) {
    this.disableTooltip = disable;
  },

  <div id="method-Ext.ux.Flot-findSeries"></div>/**
   * 系列を検索します
   * @param {String} name 検索する系列名
   * @return {Object} 見つかった系列 (見つからなければ null)
   */
  findSeries: function(name) {
    var series = this.getData();
    for (var i = 0, len = series.length; i < len; i++) {
      var idx = series[i].dataIndex || series[i].label;
      if (name === idx || name === series[i].id) { return series[i]; }
    }
    return null;
  },

  // private
  setupSeries: function(series) {
    if (typeof series.length == 'undefined') {series = [series];}
    for (var i = 0, len = series.length; i < len; i++) {
      var s = series[i];
      if (typeof s.length != 'undefined') {s = series[i] = {data: s};}
      // baseSeries を適用
      Ext.apply(s, this.baseSeries);
      // legend lines points bars pies は必ず作る
      Ext.applyIf(s, {
        id: Ext.id(null, 'flot-series'),
        /*
        lines:  Ext.apply({}, s.lines),
        points: Ext.apply({}, s.points),
        bars:   Ext.apply({}, s.bars),
        pies:   Ext.apply({}, s.pies),
        */
        legend: Ext.apply({}, s.legend),
        selectable: true,
        hidden: false
      });
    }
    return series;
  },

  <div id="method-Ext.ux.Flot-plot"></div>/**
   * flot の plot を呼び出します。
   * @param {Array} series 描画する系列群
   */
  plot: function(series) {
    // 再描画時のためにコピーする
    var _series = [];
    for (var i = 0, len = series.length; i < len; i++) {
      _series.push(Ext.apply({}, series[i]));
      if (this.flot) {
        // 再描画の場合 axes の設定を数値に置換しなおす
        var axes = this.getAxes();
        var s = _series[i];
        if (s.xaxis && typeof s.xaxis != 'number') {
          s.xaxis = (s.xaxis == axes.x2axis) ? '2' : '1';
        }
        if (s.yaxis && typeof s.yaxis != 'number') {
          s.yaxis = (s.yaxis == axes.y2axis) ? '2' : '1';
        }
      }
    }
    if (this.fireEvent('beforedraw', this, _series) !== false) {
      this.flot = $.plot($('#' + this.id), _series, this);
      this.onDraw();
    }
  },

  <div id="method-Ext.ux.Flot-insertSeries"></div>/**
   * 新しい系列を idx の位置に挿入します。
   * @param {Object} series 挿入する系列
   * @param {Number} idx 挿入位置
   */
  insertSeries: function(series, idx) {
    var _series;
    _series = (this.flot) ? this.getData() : [];
    if (idx < 0) { idx = _series.length; }
    _series.splice(idx, 0, series);
    _series = this.setupSeries(_series);
    // FIXME 色の再設定を強制でしてしまう
    for (i = 0; i < _series.length; i++) { delete _series[i].color; }
    if (this.flot) {
      this.setData(_series);
      this.redraw();
    } else {
      this.series = _series;
    }
  },

  <div id="method-Ext.ux.Flot-prependSeries"></div>/**
   * 新しい系列を先頭に挿入します。
   * @param {Object} series 挿入する系列
   */
  prependSeries: function(series) {
    this.insertSeries(series, 0);
  },

  <div id="method-Ext.ux.Flot-appendSeries"></div>/**
   * 新しい系列を末尾に挿入します。
   * @param {Object} series 挿入する系列
   */
  appendSeries: function(series) {
    this.insertSeries(series, -1);
  },

  <div id="method-Ext.ux.Flot-insertData"></div>/**
   * 新しい系列をカレントの系列群の idx の位置に挿入します。
   * @param {Object/Array} data 系列データ
   * @param {Object} series setupData() に渡すベース系列設定
   * @param {Number} idx 挿入位置
   */
  insertData: function(data, series, idx) {
    var _series = this.setupData(data, series);
    for (var i = 0; i < _series.length; i++) {
      this.insertSeries(series[i], (idx < 0) ? idx : idx+i);
    }
  },

  <div id="method-Ext.ux.Flot-prependData"></div>/**
   * 新しい系列をカレントの系列群の先頭に挿入します。
   * @param {Object/Array} data 系列データ
   * @param {Object} series setupData() に渡すベース系列設定
   */
  prependData: function(data, series) {
    this.insertData(data, series, 0);
  },

  <div id="method-Ext.ux.Flot-appendData"></div>/**
   * 新しい系列をカレントの系列群の末尾に挿入します。
   * @param {Object/Array} data 系列データ
   * @param {Object} series setupData() に渡すベース系列設定
   */
  appendData: function(data, series) {
    this.insertData(data, series, -1);
  },

  // private
  redraw: function() {
    var series = this.getData();
    if (this.fireEvent('beforedraw', this, series) !== false) {
      this.setupGrid();
      this.draw();
      this.onDraw();
    }
  },

  <div id="method-Ext.ux.Flot-setHidden"></div>/**
   * 系列の表示・非表示を変更します。
   * @param {String/Object} series 表示・非表示を設定する系列
   * @param {Bool} hidden 表示・非表示設定
   */
  setHidden: function(series, hidden) {
    var s = (typeof series == 'string') ? this.findSeries(series) : series;
    if (s.hidable === false) { return; }
    var keys = ['lines', 'points', 'bars', 'pies'];
    if (s.hidden != hidden) {
      s.hidden = hidden;
      for (var k = 0, len = keys.length; k < len; k++) {
        var key = keys[k];
        if (hidden) {
          s[key + 'Show'] = s[key];
          s[key] = Ext.applyIf({show: false, lineWidth: 0, fill: 0}, s[key]);
        } else {
          s[key] = s[key + 'Show'] || s[key];
        }
      }
      if (hidden) {
        s.colorShow  = s.color;
        s.color      = this.grid.backgroundColor || "#ffffff";
        s.shadowSizeShow = s.shadowSize;
        s.shadowSize = 0;
      } else {
        s.color      = s.colorShow;
        s.shadowSize = s.shadowSizeShow;
      }
      this.redraw();
      this.updateAction();
      this.fireEvent(hidden ? 'plothide' : 'plotshow', this, series);
    }
  },

  <div id="method-Ext.ux.Flot-setSelection"></div>/**
   * flot setSelection のラッパー
   * @param {Object}  ranges 選択する範囲矩形
   */
  setSelection: function(ranges, preventEvent) {
    return this.flot.setSelection(ranges, preventEvent);
  },
  <div id="method-Ext.ux.Flot-clearSelection"></div>/**
   * flot clearSelection のラッパー
   * 選択を解除します。
   */
  clearSelection: function() {
    return this.flot.clearSelection();
  },
  <div id="method-Ext.ux.Flot-setCrosshair"></div>/**
   * flot setCrosshair のラッパー
   * @param {Object}
   * flot 0.5 では未対応です。
   */
  setCrosshair: function(pos) {
    return this.flot.setCrosshair(pos);
  },
  <div id="method-Ext.ux.Flot-clearCrosshair"></div>/**
   * flot clearCrosshair のラッパー
   * クロスヘアマーカをクリアします。
   * flot 0.5 では未対応です。
   */
  clearCrosshair: function() {
    return this.flot.clearCrosshair();
  },
  <div id="method-Ext.ux.Flot-highlight"></div>/**
   * flot highlight のラッパー
   * @param {Nmuber) series index
   * @param {Number} datapoint index
   */
  highlight: function(series, datapoint) {
    return this.flot.highlight(series, datapoint);
  },
  <div id="method-Ext.ux.Flot-unhighlight"></div>/**
   * flot unhighlight のラッパー
   * @param {Number} 対象の系列
   * @param {Number} ハイライトを消す点
   */
  unhighlight: function(series, datapoint) {
    return this.flot.unhighlight(series, datapoint);
  },
  <div id="method-Ext.ux.Flot-setData"></div>/**
   * flot setData のラッパー
   * @param {Array} 設定する系列
   */
  setData: function(series) {
    return this.flot.setData(series);
  },
  <div id="method-Ext.ux.Flot-setupGrid"></div>/**
   * flot setupGrid のラッパー
   */
  setupGrid: function() {
    return this.flot.setupGrid();
  },
  <div id="method-Ext.ux.Flot-draw"></div>/**
   * flot draw のラッパー
   * カレントの状態でキャンバスを再描画します
   */
  draw: function() {
    return this.flot.draw();
  },
  <div id="method-Ext.ux.Flot-getData"></div>/**
   * flot getData のラッパー
   * @return {Array} カレントの保持している系列の配列
   */
  getData: function() {
    return (this.flot) ? this.flot.getData() : this.series;
  },
  <div id="method-Ext.ux.Flot-getAxes"></div>/**
   * flot getAxes のラッパー
   * @return {Object} 軸の情報群 (xaxis yaxis x2axis y2axis)
   */
  getAxes: function() {
    return this.flot.getAxes();
  },
  <div id="method-Ext.ux.Flot-getCanvas"></div>/**
   * flot getCanvas のラッパー
   * @return {Object} キャンバス
   */
  getCanvas: function() {
    return this.flot.getCanvas();
  },
  <div id="method-Ext.ux.Flot-getPlotOffset"></div>/**
   * flot getPlotOffset のラッパー
   * @return {Object} プロット領域のオフセット情報 (left, bottom, right, top)
   */
  getPlotOffset: function() {
    return this.flot.getPlotOffset();
  }
});
Ext.reg('flot', Ext.ux.Flot);

<div id="cls-Ext.ux.Flot.grid"></div>/**
 * @class Ext.ux.Flot.grid
 * @singleton
 * flot の grid に関連するメソッド群です。
 * Ext の grid のことではないので注意してください。
 */
Ext.ns('Ext.ux.Flot.grid');

<div id="method-Ext.ux.Flot.grid-weekendMarkings"></div>/**
 * 週末をマーキングする flot のグリッドテンプレートです
 * 通常 grid.markings に指定して使います
 * 現在 X 軸 (xaxis) に対してのみ有効です
<pre>
grid: { markings: Ext.ux.Flot.grid.weekendMarkings }
</pre>
 * @param {Object} axes 軸設定
 * @return {Array} マーキングする範囲を Array で返します
 * TODO yaxis x2axis y2axis に対応していません
 * @member Ext.ux.Flot.grid
 * @method weekendMarkings
 */
Ext.ux.Flot.grid.weekendMarkings = function(axes) {
  var markings = [];
  var d = new Date(axes.xaxis.min);
  // go to the first Saturday
  d.setUTCDate(d.getUTCDate() - ((d.getUTCDay() + 1) % 7));
  d.setUTCSeconds(0);
  d.setUTCMinutes(0);
  d.setUTCHours(0);
  var i = d.getTime();
  do {
    // when we don't set yaxis the rectangle automatically
    // extends to infinity upwards and downwards
    markings.push({ xaxis: { from: i, to: i + 2 * 24 * 60 * 60 * 1000 } });
    i += 7 * 24 * 60 * 60 * 1000;
  } while (i < axes.xaxis.max);

  return markings;
};

<div id="cls-Ext.ux.FlotPropertyGrid"></div>/**
 * @class Ext.ux.FlotPropertyGrid
 * @extends Ext.grid.GridPanel
 * Ext Flot の標準のプロパティ用のグリッドです。
 * flot.store にセットされている情報をグリッドで表示します。
 * @constructor
 * @param {Object} config 設定オブジェクト
 */
Ext.ux.FlotPropertyGrid = Ext.extend(Ext.grid.GridPanel, {
  // private
  initComponent: function() {
    var cm = [{
      header:    'X',
      dataIndex: 'xaxis',
      sortable:  true
    }, {
      header:    'X2',
      dataIndex: 'x2axis',
      hidden:    true,
      sortable:  true
    }];
    var series = this.flot.getData();
    for (var i = 0, len = series.length; i < len; i++) {
      var s = series[i];
      var renderer = function(value, cell, rec) {
        cell.css = 'background: ' + s.color;
        return value;
      };
      var c = {
        header:    s.label || _('Series') + ' ' + i,
        dataIndex: s.label || i,
        hidden:    s.hidden,
        renderer:  renderer,
        sortable:  true
      };
      cm.push(Ext.apply(c, this.basePropertyColumn));
    }

    Ext.applyIf(this, {
      store: this.flot.getStore(),
      cm: new Ext.grid.ColumnModel(cm),
      sm: new Ext.grid.CellSelectionModel({
        singleSelect: false
      }),
      viewConfig: {
        //columnsText: _('Columns'),
        emptyText: _('No Data')
      }
    });
    Ext.ux.FlotPropertyGrid.superclass.initComponent.call(this);
  }
});
Ext.reg('flotpropertygrid', Ext.ux.FlotPropertyGrid);
</pre>    
</body>
</html>